## Why Foton?

This article explains the motivation behind the Foton project and its goals.

TL;DR: Developers struggle with the TON development ecosystem because of the lack of beginner-friendly and high-level tools. Foton aims to solve this problem by adapting proven solutions from the Ethereum ecosystem.

## Problem statement

The Open Network (TON) development ecosystem is fast-growing and constantly evolving. After years of development, it changed radically.
As an example, the first smart contract language for TON was a low-level Fift. It was replaced some time later by the easier-to-understand FunC.
These days, the community is working on a high-level Tact language, which brings high-level programming features to the TON smart contracts.

The situation with the JavaScript ecosystem in TON is the opposite to smart contracts. The long-standing libraries like [`@ton/core`](https://github.com/ton-org/ton) and [`tonweb`](https://github.com/toncenter/tonweb) are,
in a way, low-level. They require deep understanding of TON blockchain and its architecture. To compose a transaction payload,
developers need to know what are cells and slices, how to serialize them, etc. Moreover, documentation for the mentioned libraries is auto-generated and doesn't help with learning.

Existing libraries are not beginner-friendly. It creates a barrier for newcomers to start developing dApps on TON. As a result, the ecosystem looses potential developers and projects.

**A better developer experience is crucial for the growth of the ecosystem.**

## Solution

Looking at the Ethereum ecosystem, we can see a real competition between the JavaScript libraries.
This competition results in the best developer experience. It started with [web3.js](https://web3js.org/) in 2015, got overrun by a better alternative [ethers.js](https://docs.ethers.org/v5/).
These days, the tools like [Viem](https://viem.sh/) and [Thirdweb](https://thirdweb.com/)
are setting standards for the Ethereum JavaScript toolkits.

The libraries like Viem and Thirdweb abstract the complexity of the blockchain and export the API for real use cases: connecting to a wallet, sending transactions, deploying contracts, reading state, etc.

**Foton takes the best from Ethereum and applies it to the best of TON.**

Take a look at how easy it is to connect to any of supported wallets with Foton:

```ts
import { createWalletClientUI } from '@fotonjs/core';

export const walletClient = createWalletClientUI({
  manifestUrl: 'https://example.com/tonconnect-manifest.json',
});

const wallet = await walletClient.connect();
```

The snippet above creates a [WalletClient](/docs/wallet-client) instance and calls a `connect` method. In browser, user will see a modal with the list of supported wallets. They select one and immediately establish a connection.

The same simplicity applies to other parts of the Foton library. For example, to deploy a contract, one can write:

```ts
import { createContractClient, parseTon } from '@fotonjs/core';
import { Counter } from './contracts/Counter';

export const contractClient = createContractClient({
  contract: Counter,
  publicClient,
  walletClient,
});

const res = await counterClient.deploy({
  value: parseTon('0.05'),
  arguments: [],
  payload: {
    queryId: BigInt(Math.floor(Math.random() * 1000)),
  },
});
```

In here, Foton uses the compilation result of the Tact or FunC compiler â€“ a TypeScript class describing the contract. This is all Foton needs to deploy, write and read from the contract.
